<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>TinyWebServer | fs blog in xmu</title><meta name="author" content="fs"><meta name="copyright" content="fs"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线程同步机制封装类RAII RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.  在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定">
<meta property="og:type" content="article">
<meta property="og:title" content="TinyWebServer">
<meta property="og:url" content="http://fsxmu.gi.io.com/2023/04/10/TinyWebServer/index.html">
<meta property="og:site_name" content="fs blog in xmu">
<meta property="og:description" content="线程同步机制封装类RAII RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.  在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/we/wallhaven-we52vx.jpg">
<meta property="article:published_time" content="2023-04-10T15:36:33.000Z">
<meta property="article:modified_time" content="2023-04-11T11:58:00.768Z">
<meta property="article:author" content="fs">
<meta property="article:tag" content="web服务器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/we/wallhaven-we52vx.jpg"><link rel="shortcut icon" href="https://w.wallhaven.cc/full/jx/wallhaven-jxwwe5.png"><link rel="canonical" href="http://fsxmu.gi.io.com/2023/04/10/TinyWebServer/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'TinyWebServer',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-11 19:58:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://w.wallhaven.cc/full/we/wallhaven-we52vx.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/5g/wallhaven-5gzl88.png')"><nav id="nav"><span id="blog-info"><a href="/" title="fs blog in xmu"><span class="site-name">fs blog in xmu</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">TinyWebServer</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-10T15:36:33.000Z" title="发表于 2023-04-10 23:36:33">2023-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-11T11:58:00.768Z" title="更新于 2023-04-11 19:58:00">2023-04-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/web%E6%9C%8D%E5%8A%A1%E5%99%A8/">web服务器</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="TinyWebServer"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="线程同步机制封装类"><a href="#线程同步机制封装类" class="headerlink" title="线程同步机制封装类"></a>线程同步机制封装类</h3><h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a><strong>RAII</strong></h4><ul>
<li><p>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.</p>
</li>
<li><p>在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定</p>
</li>
<li><p>RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a><strong>信号量</strong></h4><p>信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V).假设有信号量SV，对其的P、V操作如下：</p>
<blockquote>
<ul>
<li>P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行</li>
<li>V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一</li>
</ul>
</blockquote>
<p>信号量的取值可以是任何自然数，最常用的，最简单的信号量是二进制信号量，只有0和1两个值.</p>
<blockquote>
<ul>
<li>sem_init函数用于初始化一个未命名的信号量</li>
<li>sem_destory函数用于销毁信号量</li>
<li>sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞</li>
<li>sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程</li>
</ul>
</blockquote>
<p>以上，成功返回0，失败返回errno</p>
<h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a><strong>互斥量</strong></h4><p>互斥锁,也成互斥量,可以保护关键代码段,以确保独占式访问.当进入关键代码段,获得互斥锁将其加锁;离开关键代码段,唤醒等待该互斥锁的线程.</p>
<blockquote>
<ul>
<li>pthread_mutex_init函数用于初始化互斥锁</li>
<li>pthread_mutex_destory函数用于销毁互斥锁</li>
<li>pthread_mutex_lock函数以原子操作方式给互斥锁加锁</li>
<li>pthread_mutex_unlock函数以原子操作方式给互斥锁解锁</li>
</ul>
</blockquote>
<p>以上，成功返回0，失败返回errno</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a><strong>条件变量</strong></h4><p>条件变量提供了一种线程间的通知机制,当某个共享数据达到某个值时,唤醒等待这个共享数据的线程.</p>
<blockquote>
<ul>
<li>pthread_cond_init函数用于初始化条件变量</li>
<li>pthread_cond_destory函数销毁条件变量</li>
<li>pthread_cond_broadcast函数以广播的方式唤醒<strong>所有</strong>等待目标条件变量的线程</li>
<li>pthread_cond_wait函数用于等待目标条件变量.该函数调用时需要传入 <strong>mutex参数(加锁的互斥锁)</strong> ,函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. <strong>也就是说函数内部会有一次解锁和加锁操作</strong>.</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="锁机制的功能"><a href="#锁机制的功能" class="headerlink" title="锁机制的功能"></a><strong>锁机制的功能</strong></h4><ul>
<li>实现多线程同步，通过锁机制，确保任一时刻只能有一个线程能进入关键代码段.</li>
</ul>
<h4 id="封装的功能"><a href="#封装的功能" class="headerlink" title="封装的功能"></a><strong>封装的功能</strong></h4><ul>
<li>类中主要是Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>class sem&#123;</span><br><span class="line"> <span class="number">2</span>    public:</span><br><span class="line"> <span class="number">3</span>        <span class="comment">//构造函数</span></span><br><span class="line"> <span class="number">4</span>        sem()</span><br><span class="line"> <span class="number">5</span>        &#123;</span><br><span class="line"> <span class="number">6</span>            <span class="comment">//信号量初始化</span></span><br><span class="line"> <span class="number">7</span>            <span class="keyword">if</span>(sem_init(&amp;m_sem,<span class="number">0</span>,<span class="number">0</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line"> <span class="number">8</span>                throw <span class="built_in">std</span>::exception();</span><br><span class="line"> <span class="number">9</span>            &#125;</span><br><span class="line"><span class="number">10</span>        &#125;</span><br><span class="line"><span class="number">11</span>        <span class="comment">//析构函数</span></span><br><span class="line"><span class="number">12</span>        ~sem()</span><br><span class="line"><span class="number">13</span>        &#123;</span><br><span class="line"><span class="number">14</span>            <span class="comment">//信号量销毁</span></span><br><span class="line"><span class="number">15</span>            sem_destroy(&amp;m_sem);</span><br><span class="line"><span class="number">16</span>        &#125;</span><br><span class="line"><span class="number">17</span>    private:</span><br><span class="line"><span class="number">18</span>        <span class="type">sem_t</span> m_sem;</span><br><span class="line"><span class="number">19</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>将重复使用的代码封装为函数，减少代码的重复，使其更简洁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   <span class="comment">//条件变量的使用机制需要配合锁来使用</span></span><br><span class="line"> <span class="number">2</span>   <span class="comment">//内部会有一次加锁和解锁</span></span><br><span class="line"> <span class="number">3</span>   <span class="comment">//封装起来会使得更加简洁</span></span><br><span class="line"> <span class="number">4</span>   <span class="type">bool</span> <span class="title function_">wait</span><span class="params">()</span></span><br><span class="line"> 5   &#123;</span><br><span class="line"> <span class="number">6</span>       <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line"> <span class="number">7</span>       pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line"> <span class="number">8</span>       ret=pthread_cond_wait(&amp;m_cond,&amp;m_mutex);</span><br><span class="line"> <span class="number">9</span>       pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line"><span class="number">10</span>       <span class="keyword">return</span> ret==<span class="number">0</span>;</span><br><span class="line"><span class="number">11</span>   &#125;</span><br><span class="line"><span class="number">12</span>   <span class="type">bool</span> <span class="title function_">signal</span><span class="params">()</span></span><br><span class="line">13   &#123;</span><br><span class="line"><span class="number">14</span>       <span class="keyword">return</span> pthread_cond_signal(&amp;m_cond)==<span class="number">0</span>;</span><br><span class="line"><span class="number">15</span>   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Web服务器如何接收客户端发来的HTTP请求报文呢"><a href="#Web服务器如何接收客户端发来的HTTP请求报文呢" class="headerlink" title="Web服务器如何接收客户端发来的HTTP请求报文呢?"></a>Web服务器如何接收客户端发来的HTTP请求报文呢?</h3><p>Web服务器端通过<code>socket</code>监听来自用户的请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 创建监听socket文件描述符 */</span></span><br><span class="line"><span class="type">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* 创建监听socket的TCP/IP的IPV4 socket地址 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">address.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">/* INADDR_ANY：将套接字绑定到所有可用的接口 */</span></span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* SO_REUSEADDR 允许端口被重复使用 */</span></span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line"><span class="comment">/* 绑定socket和它的地址 */</span></span><br><span class="line">ret = bind(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));  </span><br><span class="line"><span class="comment">/* 创建监听队列以存放待处理的客户连接，在这些客户连接被accept()之前 */</span></span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>远端的很多用户会尝试去<code>connect()</code>这个Web Server上正在<code>listen</code>的这个<code>port</code>，而监听到的这些连接会排队等待被<code>accept()</code>。由于用户连接请求是随机到达的异步事件，每当监听socket（<code>listenfd</code>）<code>listen</code>到新的客户连接并且放入监听队列，我们都需要告诉我们的Web服务器有连接来了，<code>accept</code>这个连接，并分配一个逻辑单元来处理这个用户请求。而且，我们在处理这个请求的同时，还需要继续监听其他客户的请求并分配其另一逻辑单元来处理（并发，同时处理多个事件，后面会提到使用线程池实现并发）。这里，服务器通过<strong>epoll</strong>这种I&#x2F;O复用技术（还有select和poll）来实现对监听socket（<code>listenfd</code>）和连接socket（客户请求）的同时监听。注意I&#x2F;O复用虽然可以同时监听多个文件描述符，但是它本身是阻塞的，并且当有多个文件描述符同时就绪的时候，如果不采取额外措施，程序则只能按顺序处理其中就绪的每一个文件描述符，所以为提高效率，我们将在这部分通过线程池来实现并发（多线程并发），为每个就绪的文件描述符分配一个逻辑单元（线程）来处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件中 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot)</span> &#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="comment">/* 针对connfd，开启EPOLLONESHOT，因为我们希望每个socket在任意时刻都只被一个线程处理 */</span></span><br><span class="line">    <span class="keyword">if</span>(one_shot)</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 创建一个额外的文件描述符来唯一标识内核中的epoll事件表 */</span></span><br><span class="line"><span class="type">int</span> epollfd = epoll_create(<span class="number">5</span>);  </span><br><span class="line"><span class="comment">/* 用于存储epoll事件表中就绪事件的event数组 */</span></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];  </span><br><span class="line"><span class="comment">/* 主线程往epoll内核事件表中注册监听socket事件，当listen到新的客户连接时，listenfd变为就绪事件 */</span></span><br><span class="line">addfd(epollfd, listenfd, <span class="literal">false</span>);  </span><br><span class="line"><span class="comment">/* 主线程调用epoll_wait等待一组文件描述符上的事件，并将当前所有就绪的epoll_event复制到events数组中 */</span></span><br><span class="line"><span class="type">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/* 然后我们遍历这一数组以处理这些已经就绪的事件 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = events[i].data.fd;  <span class="comment">// 事件表中就绪的socket文件描述符</span></span><br><span class="line">    <span class="keyword">if</span>(sockfd == listenfd) &#123;  <span class="comment">// 当listen到新的用户连接，listenfd上则产生就绪事件</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">        <span class="type">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">        <span class="comment">/* ET模式 */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* accept()返回一个新的socket文件描述符用于send()和recv() */</span></span><br><span class="line">            <span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">            <span class="comment">/* 并将connfd注册到内核事件表中 */</span></span><br><span class="line">            users[connfd].init(connfd, client_address);</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">        <span class="comment">// 如有异常，则直接关闭客户连接，并删除该用户的timer</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">        <span class="comment">/* 当这一sockfd上有可读事件时，epoll_wait通知主线程。*/</span></span><br><span class="line">        <span class="keyword">if</span>(users[sockfd].read()) &#123; <span class="comment">/* 主线程从这一sockfd循环读取数据, 直到没有更多数据可读 */</span></span><br><span class="line">            pool-&gt;append(users + sockfd);  <span class="comment">/* 然后将读取到的数据封装成一个请求对象并插入请求队列 */</span></span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">        <span class="comment">/* 当这一sockfd上有可写事件时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果 */</span></span><br><span class="line">        <span class="keyword">if</span>(users[sockfd].write()) &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器程序通常需要处理三类事件：I&#x2F;O事件，信号及定时事件。有两种事件处理模式：</p>
<ul>
<li>Reactor模式：要求主线程（I&#x2F;O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理。</li>
<li>Proactor模式：将所有的I&#x2F;O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后<code>users[sockfd].read()</code>，选择一个工作线程来处理客户请求<code>pool-&gt;append(users + sockfd)</code>。</li>
</ul>
<p>通常使用同步I&#x2F;O模型（如<code>epoll_wait</code>）实现Reactor，使用异步I&#x2F;O（如<code>aio_read</code>和<code>aio_write</code>）实现Proactor。但在此项目中，我们使用的是<strong>同步I&#x2F;O模拟的Proactor</strong>事件处理模式。那么什么是同步I&#x2F;O，什么是异步I&#x2F;O呢？</p>
<ul>
<li>同步（阻塞）I&#x2F;O：在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。</li>
<li>异步（非阻塞）I&#x2F;O：当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。</li>
</ul>
<h3 id="同步I-x2F-O模拟proactor模式"><a href="#同步I-x2F-O模拟proactor模式" class="headerlink" title="同步I&#x2F;O模拟proactor模式"></a>同步I&#x2F;O模拟proactor模式</h3><p>由于异步I&#x2F;O并不成熟，实际中使用较少，这里将使用同步I&#x2F;O模拟实现proactor模式。</p>
<p>同步I&#x2F;O模型的工作流程如下（epoll_wait为例）：</p>
<blockquote>
<ul>
<li>主线程往epoll内核事件表注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读</li>
<li>当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li>
</ul>
</blockquote>
<p>Linux下有三种IO复用方式：epoll，select和poll，为什么用epoll，它和其他两个有什么区别呢？</p>
<ul>
<li>对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。</li>
<li>select使用线性表描述文件描述符集合，文件描述符有上限；poll使用链表来描述；epoll底层通过红黑树来描述，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。</li>
<li>select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。</li>
<li>select和poll都只能工作在相对低效的LT模式下，而epoll同时支持LT和ET模式。</li>
<li>综上，当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。</li>
</ul>
<p><code>Epoll</code>对文件操作符的操作有两种模式：LT（电平触发）和ET（边缘触发），二者的区别在于当你调用<code>epoll_wait</code>的时候内核里面发生了什么：</p>
<ul>
<li>LT（电平触发）：类似<code>select</code>，LT会去遍历在epoll事件表中每个文件描述符，来观察是否有我们感兴趣的事件发生，如果有（触发了该文件描述符上的回调函数），<code>epoll_wait</code>就会以非阻塞的方式返回。若该epoll事件没有被处理完（没有返回<code>EWOULDBLOCK</code>），该事件还会被后续的<code>epoll_wait</code>再次触发。</li>
<li>ET（边缘触发）：ET在发现有我们感兴趣的事件发生后，立即返回，并且<code>sleep</code>这一事件的<code>epoll_wait</code>，不管该事件有没有结束。</li>
</ul>
<p>在使用ET模式时，必须要保证该文件描述符是非阻塞的（确保在没有数据可读时，该文件描述符不会一直阻塞）；并且每次调用<code>read</code>和<code>write</code>的时候都必须等到它们返回<code>EWOULDBLOCK</code>（确保所有数据都已读完或写完）。</p>
<h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a><strong>静态成员变量</strong></h4><p>将类成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。</p>
<p>静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区。</p>
<ul>
<li><p>静态成员变量</p>
</li>
<li><ul>
<li>最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。</li>
<li>无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。</li>
<li>非静态成员类外不能初始化。</li>
<li>静态成员数据是共享的。</li>
</ul>
</li>
</ul>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a><strong>静态成员函数</strong></h4><p>将类成员函数声明为static，则为静态成员函数。</p>
<ul>
<li><p>静态成员函数</p>
</li>
<li><ul>
<li>静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。</li>
<li>普通成员函数可以访问普通成员变量，也可以访问静态成员变量。</li>
<li>静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。</li>
</ul>
</li>
</ul>
<h4 id="pthread-create陷阱"><a href="#pthread-create陷阱" class="headerlink" title="pthread_create陷阱"></a><strong>pthread_create陷阱</strong></h4><p>首先看一下该函数的函数原型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="number">2</span><span class="type">int</span> <span class="title function_">pthread_create</span> <span class="params">(<span class="type">pthread_t</span> *thread_tid,   <span class="comment">//返回新生成的线程的id</span></span></span><br><span class="line"><span class="params"><span class="number">3</span>        <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,         <span class="comment">//指向线程属性的指针,通常设置为NULL</span></span></span><br><span class="line"><span class="params"><span class="number">4</span>        <span class="type">void</span> * (*start_routine) (<span class="type">void</span> *),   <span class="comment">//处理线程函数的地址</span></span></span><br><span class="line"><span class="params"><span class="number">5</span>        <span class="type">void</span> *arg)</span>;                         <span class="comment">//start_routine()中的参数</span></span><br></pre></td></tr></table></figure>

<p>函数原型中的第三个参数，为函数指针，指向处理线程函数的地址。该函数，要求为静态函数。如果处理线程函数为类成员函数时，需要将其设置为<strong>静态成员函数</strong>。</p>
<h4 id="this指针的锅"><a href="#this指针的锅" class="headerlink" title="this指针的锅"></a><strong>this指针的锅</strong></h4><p>pthread_create的函数原型中第三个参数的类型为函数指针，指向的线程处理函数参数类型为<code>(void *)</code>,若线程函数为类成员函数，则this指针会作为默认的参数被传进函数中，从而和线程函数参数<code>(void*)</code>不能匹配，不能通过编译。</p>
<p>静态成员函数就没有这个问题，里面没有this指针。</p>
<h3 id="Web服务器如何处理以及响应接收到的HTTP请求报文呢"><a href="#Web服务器如何处理以及响应接收到的HTTP请求报文呢" class="headerlink" title="Web服务器如何处理以及响应接收到的HTTP请求报文呢?"></a>Web服务器如何处理以及响应接收到的HTTP请求报文呢?</h3><p>该项目使用线程池（半同步半反应堆模式）并发处理用户请求，主线程负责读写，工作线程（线程池中的线程）负责处理逻辑（HTTP请求报文的解析等等）。通过之前的代码，我们将<code>listenfd</code>上到达的<code>connection</code>通过 <code>accept()</code>接收，并返回一个新的socket文件描述符<code>connfd</code>用于和用户通信，并对用户请求返回响应，同时将这个<code>connfd</code>注册到内核事件表中，等用户发来请求报文。这个过程是：通过<code>epoll_wait</code>发现这个<code>connfd</code>上有可读事件了（<code>EPOLLIN</code>），主线程就将这个HTTP的请求报文读进这个连接socket的读缓存中<code>users[sockfd].read()</code>，然后将该任务对象（指针）插入线程池的请求队列中<code>pool-&gt;append(users + sockfd);</code>，线程池的实现还需要依靠<strong>锁机制</strong>以及<strong>信号量</strong>机制来实现线程同步，保证操作的原子性。</p>
<ul>
<li>所谓线程池，就是一个<code>pthread_t</code>类型的普通数组，通过<code>pthread_create()</code>函数创建<code>m_thread_number</code>个<strong>线程</strong>，用来执行<code>worker()</code>函数以执行每个请求处理函数（HTTP请求的<code>process</code>函数），通过<code>pthread_detach()</code>将线程设置成脱离态（detached）后，当这一线程运行结束时，它的资源会被系统自动回收，而不再需要在其它线程中对其进行 <code>pthread_join()</code> 操作。</li>
<li>操作工作队列一定要加锁（<code>locker</code>），因为它被所有线程共享。</li>
<li>我们用信号量来标识请求队列中的请求数，通过<code>m_queuestat.wait();</code>来等待一个请求队列中待处理的HTTP请求，然后交给线程池中的空闲线程来处理。</li>
</ul>
<p><strong>为什么要使用线程池？</strong></p>
<p>当你需要限制你应用程序中同时运行的线程数时，线程池非常有用。因为启动一个新线程会带来性能开销，每个线程也会为其堆栈分配一些内存等。为了任务的并发执行，我们可以将这些任务任务传递到线程池，而不是为每个任务动态开启一个新的线程。</p>
<p><strong>线程池中的线程数量是依据什么确定的</strong></p>
<p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量<code>N</code>：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费，公式：<code>最佳线程数 = CPU当前可使用的Cores数 * 当前CPU的利用率 * (1 + CPU等待时间 / CPU处理时间)</code></p>
<p>HTTP请求的入口函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();</span><br><span class="line">    <span class="keyword">if</span>(read_ret == NO_REQUEST) &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> write_ret = <span class="built_in">process_write</span>(read_ret);</span><br><span class="line">    <span class="keyword">if</span>(!write_ret)</span><br><span class="line">        <span class="built_in">close_conn</span>();</span><br><span class="line">    <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，<code>process_read()</code>，也就是对我们读入该<code>connfd</code>读缓冲区的请求报文进行解析。<br>HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成有。两种请求报文</p>
<p><strong>GET</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="number">562f</span>25980001b1b106000338.jpg HTTP/<span class="number">1.1</span></span><br><span class="line">Host:img.mukewang.com</span><br><span class="line">User-Agent:Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; WOW64)</span><br><span class="line">AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">51.0</span><span class="number">.2704</span><span class="number">.106</span> Safari/<span class="number">537.36</span></span><br><span class="line">Accept:image/webp,image<span class="comment">/*,*/</span>*;q=<span class="number">0.8</span></span><br><span class="line">Referer:http:<span class="comment">//www.imooc.com/</span></span><br><span class="line">Accept-Encoding:gzip, deflate, sdch</span><br><span class="line">Accept-Language:zh-CN,zh;q=<span class="number">0.8</span></span><br><span class="line">空行</span><br><span class="line">请求数据为空</span><br></pre></td></tr></table></figure>

<p><strong>POST</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1<span class="number">.1</span></span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/<span class="number">4.0</span> (compatible; MSIE <span class="number">6.0</span>; Windows NT <span class="number">5.1</span>; SV1; .NET CLR <span class="number">2.0</span><span class="number">.50727</span>; .NET CLR <span class="number">3.0</span><span class="number">.04506</span><span class="number">.648</span>; .NET CLR <span class="number">3.5</span><span class="number">.21022</span>)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:<span class="number">40</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">空行</span><br><span class="line">name=Professional%<span class="number">20</span>Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure>

<p><strong>GET和POST的区别</strong></p>
<ul>
<li>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制。（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。</li>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100（指示信息—表示请求已接收，继续处理）continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
</ul>
<p><code>process_read()</code>函数的作用就是将类似上述例子的请求报文进行解析，因为用户的请求内容包含在这个请求报文里面，只有通过解析，知道用户请求的内容是什么，是请求图片，还是视频，或是其他请求，我们根据这些请求返回相应的HTML页面等。项目中使用<strong>主从状态机</strong>的模式进行解析，从状态机（<code>parse_line</code>）负责读取报文的一行，主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。每解析一部分都会将整个请求的<code>m_check_state</code>状态改变，状态机也就是根据这个状态来进行不同部分的解析跳转的：</p>
<ul>
<li><code>parse_request_line(text)</code>，解析请求行，也就是GET中的<code>GET /562f25980001b1b106000338.jpg HTTP/1.1</code>这一行，或者POST中的<code>POST / HTTP1.1</code>这一行。通过请求行的解析我们可以判断该HTTP请求的类型（GET&#x2F;POST），而请求行中最重要的部分就是<code>URL</code>部分，我们会将这部分保存下来用于后面的生成HTTP响应。</li>
<li><code>parse_headers(text);</code>，解析请求头部，GET和POST中<code>空行</code>以上，请求行以下的部分。</li>
<li><code>parse_content(text);</code>，解析请求数据，对于GET来说这部分是空的，因为这部分内容已经以明文的方式包含在了请求行中的<code>URL</code>部分了；只有POST的这部分是有数据的，项目中的这部分数据为用户名和密码，我们会根据这部分内容做登录和校验，并涉及到与数据库的连接。</li>
</ul>
<p>当得到一个完整的，正确的HTTP请求时，就到了<code>do_request</code>代码部分，我们需要首先对GET请求和不同POST请求（登录，注册，请求图片，视频等等）做不同的预处理，然后分析目标文件的属性，若目标文件存在、对所有用户可读且不是目录时，则使用<code>mmap</code>将其映射到内存地址<code>m_file_address</code>处，并告诉调用者获取文件成功。</p>
<p>假设你已经搭好了你的HTTP服务器，然后你在本地浏览器中键入<code>localhost:9000</code>，然后回车，这时候你就给你的服务器发送了一个GET请求，什么都没做，然后服务器端就会解析你的这个HTTP请求，然后发现是个GET请求，然后返回给你一个静态HTML页面，也就是项目中的<code>judge.html</code>页面，那POST请求怎么来的呢？这时你会发现，返回的这个<code>judge</code>页面中包含着一些<code>新用户</code>和<code>已有账号</code>这两个<code>button</code>元素，当你用鼠标点击这个<code>button</code>时，你的浏览器就会向你的服务器发送一个POST请求，服务器段通过检查<code>action</code>来判断你的POST请求类型是什么，进而做出不同的响应。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* judge.html */</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>WebServer<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">&quot;5&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">strong</span>&gt;</span>欢迎访问<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;0&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>新用户<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;1&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> &gt;</span>已有账号<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="数据库连接池是如何运行的"><a href="#数据库连接池是如何运行的" class="headerlink" title="数据库连接池是如何运行的"></a>数据库连接池是如何运行的</h3><p>在处理用户注册，登录请求的时候，我们需要将这些用户的用户名和密码保存下来用于新用户的注册及老用户的登录校验，相信每个人都体验过，当你在一个网站上注册一个用户时，应该经常会遇到“您的用户名已被使用”，或者在登录的时候输错密码了网页会提示你“您输入的用户名或密码有误”等等类似情况，这种功能是服务器端通过用户键入的用户名密码和数据库中已记录下来的用户名密码数据进行校验实现的。若每次用户请求我们都需要新建一个数据库连接，请求结束后我们释放该数据库连接，当用户请求连接过多时，这种做法过于低效，所以类似<strong>线程池</strong>的做法，我们构建一个数据库连接池，预先生成一些数据库连接放在那里供用户请求使用。</p>
<ol>
<li>使用<code>mysql_init()</code>初始化连接</li>
<li>使用<code>mysql_real_connect()</code>建立一个到mysql数据库的连接</li>
<li>使用<code>mysql_query()</code>执行查询语句</li>
<li>使用<code>result = mysql_store_result(mysql)</code>获取结果集</li>
<li>使用<code>mysql_num_fields(result)</code>获取查询的列数，<code>mysql_num_rows(result)</code>获取结果集的行数</li>
<li>通过<code>mysql_fetch_row(result)</code>不断获取下一行，然后循环输出</li>
<li>使用<code>mysql_free_result(result)</code>释放结果集所占内存</li>
<li>使用<code>mysql_close(conn)</code>关闭连接</li>
</ol>
<p>对于一个数据库连接池来讲，就是预先生成多个这样的数据库连接，然后放在一个链表中，同时维护最大连接数<code>MAX_CONN</code>，当前可用连接数<code>FREE_CONN</code>和当前已用连接数<code>CUR_CONN</code>这三个变量。同样注意在对连接池操作时（获取，释放），要用到锁机制，因为它被所有线程共享。</p>
<h3 id="什么是CGI校验"><a href="#什么是CGI校验" class="headerlink" title="什么是CGI校验"></a>什么是CGI校验</h3><p>对用户的登录及注册等POST请求，服务器是如何做校验的。当点击<code>新用户</code>按钮时，服务器对这个POST请求的响应是：返回用户一个登录界面；当你在用户名和密码框中输入后，你的POST请求报文中会连同你的用户名密码一起发给服务器，然后我们拿着你的用户名和密码在数据库连接池中取出一个连接用于<code>mysql_query()</code>进行查询.</p>
<p>CGI（通用网关接口），它是一个运行在Web服务器上的程序，在编译的时候将相应的<code>.cpp</code>文件编程成<code>.cgi</code>文件并在主程序中调用即可（通过社长的<code>makefile</code>文件内容也可以看出）。这些CGI程序通常通过客户在其浏览器上点击一个<code>button</code>时运行。这些程序通常用来执行一些信息搜索、存储等任务，而且通常会生成一个动态的HTML网页来响应客户的HTTP请求。我们可以发现项目中的<code>sign.cpp</code>文件就是我们的CGI程序，将用户请求中的用户名和密码保存在一个<code>id_passwd.txt</code>文件中，通过将数据库中的用户名和密码存到一个<code>map</code>中用于校验。在主程序中通过<code>execl(m_real_file, &amp;flag, name, password, NULL);</code>这句命令来执行这个CGI文件，这里CGI程序仅用于校验，并未直接返回给用户响应。这个CGI程序的运行通过多进程来实现，根据其返回结果判断校验结果（使用<code>pipe</code>进行父子进程的通信，子进程将校验结果写到pipe的写端，父进程在读端读取）。</p>
<h3 id="生成HTTP响应并返回给用户"><a href="#生成HTTP响应并返回给用户" class="headerlink" title="生成HTTP响应并返回给用户"></a>生成HTTP响应并返回给用户</h3><p>通过以上操作，我们已经对读到的请求做好了处理，然后也对目标文件的属性作了分析，若目标文件存在、对所有用户可读且不是目录时，则使用<code>mmap</code>将其映射到内存地址<code>m_file_address</code>处，并告诉调用者获取文件成功<code>FILE_REQUEST</code>。 接下来要做的就是根据读取结果对用户做出响应了，也就是到了<code>process_write(read_ret);</code>这一步，该函数根据<code>process_read()</code>的返回结果来判断应该返回给用户什么响应，我们最常见的就是<code>404</code>错误了，说明客户请求的文件不存在，除此之外还有其他类型的请求出错的响应，具体的可以去百度。然后呢，假设用户请求的文件存在，而且已经被<code>mmap</code>到<code>m_file_address</code>这里了，那么我们就将做如下写操作，将响应写到这个<code>connfd</code>的写缓存<code>m_write_buf</code>中去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> FILE_REQUEST: &#123;</span><br><span class="line">    add_status_line(<span class="number">200</span>, ok_200_title);</span><br><span class="line">    <span class="keyword">if</span>(m_file_stat.st_size != <span class="number">0</span>) &#123;</span><br><span class="line">        add_headers(m_file_stat.st_size);</span><br><span class="line">        m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">        m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">        m_iv[<span class="number">1</span>].iov_base = m_file_address;</span><br><span class="line">        m_iv[<span class="number">1</span>].iov_len = m_file_stat.st_size;</span><br><span class="line">        m_iv_count = <span class="number">2</span>;</span><br><span class="line">        bytes_to_send = m_write_idx + m_file_stat.st_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* ok_string = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">        add_headers(<span class="built_in">strlen</span>(ok_string));</span><br><span class="line">        <span class="keyword">if</span>(!add_content(ok_string))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将<code>状态行</code>写入写缓存，<code>响应头</code>也是要写进<code>connfd</code>的写缓存（HTTP类自己定义的，与socket无关）中的，对于请求的文件，我们已经直接将其映射到<code>m_file_address</code>里面，然后将该<code>connfd</code>文件描述符上修改为<code>EPOLLOUT</code>（可写）事件，然后<code>epoll_Wait</code>监测到这一事件后，使用<code>writev</code>来将响应信息和请求文件<strong>聚集写</strong>到<strong>TCP Socket</strong>本身定义的发送缓冲区（这个缓冲区大小一般是默认的，但我们也可以通过<code>setsockopt</code>来修改）中，交由内核发送给用户。</p>
<h3 id="服务器优化：定时器处理非活动链接"><a href="#服务器优化：定时器处理非活动链接" class="headerlink" title="服务器优化：定时器处理非活动链接"></a>服务器优化：定时器处理非活动链接</h3><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><code>非活跃</code>，是指客户端（这里是浏览器）与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。</p>
<p><code>定时事件</code>，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。</p>
<p><code>定时器</code>，是指利用结构体或其他形式，将多种定时事件进行封装起来。具体的，这里只涉及一种定时事件，即定期检测非活跃连接，这里将该定时事件与连接资源封装为一个结构体定时器。</p>
<p><code>定时器容器</code>，是指使用某种容器类数据结构，将上述多个定时器组合起来，便于对定时事件统一管理。具体的，项目中使用升序链表将所有定时器串联组织起来。</p>
<h3 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h3><p>本项目中，服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序时间链表容器将所有定时器串联起来，若主循环接收到定时通知，则在链表中依次执行定时任务。</p>
<p><code>Linux</code>下提供了三种定时的方法:</p>
<ul>
<li>socket选项SO_RECVTIMEO和SO_SNDTIMEO</li>
<li>SIGALRM信号</li>
<li>I&#x2F;O复用系统调用的超时参数</li>
</ul>
<p>三种方法没有一劳永逸的应用场景，也没有绝对的优劣。由于项目中使用的是<code>SIGALRM</code>信号，这里仅对其进行介绍，另外两种方法可以查阅游双的<code>Linux高性能服务器编程 第11章 定时器</code>。</p>
<p>具体的，利用<code>alarm</code>函数周期性地触发<code>SIGALRM</code>信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。</p>
<p>从上面的简要描述中，可以看出定时器处理非活动连接模块，主要分为两部分，其一为定时方法与信号通知流程，其二为定时器及其容器设计与定时任务的处理。</p>
<h3 id="信号通知流程"><a href="#信号通知流程" class="headerlink" title="信号通知流程"></a>信号通知流程</h3><p>Linux下的信号采用的异步处理机制，信号处理函数和当前进程是两条不同的执行路线。具体的，当进程收到信号时，操作系统会中断进程当前的正常流程，转而进入信号处理函数执行操作，完成后再返回中断的地方继续执行。</p>
<p>为避免信号竞态现象发生，信号处理期间系统不会再次触发它。所以，为确保该信号不被屏蔽太久，信号处理函数需要尽可能快地执行完毕。</p>
<p>一般的信号处理函数需要处理该信号对应的逻辑，当该逻辑比较复杂时，信号处理函数执行时间过长，会导致信号屏蔽太久。</p>
<p>这里的解决方案是，信号处理函数仅仅发送信号通知程序主循环，将信号对应的处理逻辑放在程序主循环中，由主循环执行信号对应的逻辑代码。</p>
<h4 id="统一事件源"><a href="#统一事件源" class="headerlink" title="统一事件源"></a><strong>统一事件源</strong></h4><p>统一事件源，是指将信号事件与其他事件一样被处理。</p>
<p>具体的，信号处理函数使用管道将信号传递给主循环，信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出信号值，使用I&#x2F;O复用系统调用来监听管道读端的可读事件，这样信号事件与其他文件描述符都可以通过epoll来监测，从而实现统一处理。</p>
<p>项目中，我们预先分配了<code>MAX_FD</code>个http连接对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预先为每个可能的客户连接分配一个http_conn对象</span></span><br><span class="line">http_conn* users = new http_conn[MAX_FD];</span><br></pre></td></tr></table></figure>

<p>项目中使用的是<code>SIGALRM信号</code>来实现定时器，利用<code>alarm</code>函数周期性的触发<code>SIGALRM</code>信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定时器相关参数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="type">static</span> sort_timer_lst timer_lst</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每个user（http请求）对应的timer */</span></span><br><span class="line">client_data* user_timer = new client_data[MAX_FD];</span><br><span class="line"><span class="comment">/* 每隔TIMESLOT时间触发SIGALRM信号 */</span></span><br><span class="line">alarm(TIMESLOT);</span><br><span class="line"><span class="comment">/* 创建管道，注册pipefd[0]上的可读事件 */</span></span><br><span class="line"><span class="type">int</span> ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line"><span class="comment">/* 设置管道写端为非阻塞 */</span></span><br><span class="line">setnonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">/* 设置管道读端为ET非阻塞，并添加到epoll内核事件表 */</span></span><br><span class="line">addfd(epollfd, pipefd[<span class="number">0</span>], <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">addsig(SIGALRM, sig_handler, <span class="literal">false</span>);</span><br><span class="line">addsig(SIGTERM, sig_handler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p><code>alarm</code>函数会定期触发<code>SIGALRM</code>信号，这个信号交由<code>sig_handler</code>来处理，每当监测到有这个信号的时候，都会将这个信号写到<code>pipefd[1]</code>里面，传递给主循环：</p>
<p>主循环中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 处理信号 */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sockfd == pipefd[<span class="number">0</span>] &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">    <span class="type">int</span> sig;</span><br><span class="line">    <span class="type">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">    ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// handle the error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; ret; ++j) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (signals[j]) &#123;</span><br><span class="line">                <span class="keyword">case</span> SIGALRM: &#123;</span><br><span class="line">                    timeout = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> SIGTERM: &#123;</span><br><span class="line">                    stop_server = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在读端<code>pipefd[0]</code>读到这个信号的的时候，就会将<code>timeout</code>变量置为<code>true</code>并跳出循环，让<code>timer_handler()</code>函数取出来定时器容器上的到期任务，该定时器容器是通过升序链表来实现的，从头到尾对检查任务是否超时，若超时则调用定时器的回调函数<code>cb_func()</code>，关闭该socket连接，并删除其对应的定时器<code>del_timer</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_handler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* 定时处理任务 */</span></span><br><span class="line">    timer_lst.tick();</span><br><span class="line">    <span class="comment">/* 重新定时以不断触发SIGALRM信号 */</span></span><br><span class="line">    alarm(TIMESLOT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么管道写端要非阻塞？</strong></p>
<p>send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。</p>
<p><strong>没有对非阻塞返回值处理，如果阻塞是不是意味着这一次定时事件失效了？</strong></p>
<p>是的，但定时事件是非必须立即处理的事件，可以允许这样的情况发生。</p>
<p><strong>管道传递的是什么类型？switch-case的变量冲突？</strong></p>
<p>信号本身是整型数值，管道中传递的是ASCII码表中整型数值对应的字符。</p>
<p>switch的变量一般为字符或整型，当switch的变量为字符时，case中可以是字符，也可以是字符对应的ASCII码。</p>
<h3 id="定时器设计"><a href="#定时器设计" class="headerlink" title="定时器设计"></a>定时器设计</h3><p>项目中将连接资源、定时事件和超时时间封装为定时器类，具体的，</p>
<ul>
<li>连接资源包括客户端套接字地址、文件描述符和定时器</li>
<li>定时事件为回调函数，将其封装起来由用户自定义，这里是删除非活动socket上的注册事件，并关闭</li>
<li>定时器超时时间 &#x3D; 浏览器和服务器连接时刻 + 固定时间(TIMESLOT)，可以看出，定时器使用绝对时间作为超时值，这里alarm设置为5秒，连接超时为15秒。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接资源结构体成员需要用到定时器类</span></span><br><span class="line"> <span class="number">2</span><span class="comment">//需要前向声明</span></span><br><span class="line"> <span class="number">3</span><span class="keyword">class</span> util_timer;</span><br><span class="line"> <span class="number">4</span></span><br><span class="line"> <span class="number">5</span><span class="comment">//连接资源</span></span><br><span class="line"> <span class="number">6</span><span class="keyword">struct</span> client_data</span><br><span class="line"> <span class="number">7</span>&#123;</span><br><span class="line"> <span class="number">8</span>    <span class="comment">//客户端socket地址</span></span><br><span class="line"> <span class="number">9</span>    sockaddr_in address;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>    <span class="comment">//socket文件描述符</span></span><br><span class="line"><span class="number">12</span>    <span class="type">int</span> sockfd;</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span>    <span class="comment">//定时器</span></span><br><span class="line"><span class="number">15</span>    util_timer* timer;</span><br><span class="line"><span class="number">16</span>&#125;;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">18</span><span class="comment">//定时器类</span></span><br><span class="line"><span class="number">19</span><span class="keyword">class</span> util_timer</span><br><span class="line"><span class="number">20</span>&#123;</span><br><span class="line"><span class="number">21</span><span class="keyword">public</span>:</span><br><span class="line"><span class="number">22</span>    <span class="built_in">util_timer</span>() : <span class="built_in">prev</span>( <span class="literal">NULL</span> ), <span class="built_in">next</span>( <span class="literal">NULL</span> )&#123;&#125;</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span><span class="keyword">public</span>:</span><br><span class="line"><span class="number">25</span>    <span class="comment">//超时时间</span></span><br><span class="line"><span class="number">26</span>    <span class="type">time_t</span> expire; </span><br><span class="line"><span class="number">27</span>    <span class="comment">//回调函数</span></span><br><span class="line"><span class="number">28</span>    <span class="built_in">void</span> (*cb_func)( client_data* );</span><br><span class="line"><span class="number">29</span>    <span class="comment">//连接资源</span></span><br><span class="line"><span class="number">30</span>    client_data* user_data;</span><br><span class="line"><span class="number">31</span>    <span class="comment">//前向定时器</span></span><br><span class="line"><span class="number">32</span>    util_timer* prev;</span><br><span class="line"><span class="number">33</span>    <span class="comment">//后继定时器</span></span><br><span class="line"><span class="number">34</span>    util_timer* next;</span><br><span class="line"><span class="number">35</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>定时事件，具体的，从内核事件表删除事件，关闭文件描述符，释放连接资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">//定时器回调函数</span></span><br><span class="line"> <span class="number">2</span><span class="function"><span class="type">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span></span></span><br><span class="line"><span class="function"> 3</span>&#123;</span><br><span class="line"> <span class="number">4</span>    <span class="comment">//删除非活动连接在socket上的注册事件</span></span><br><span class="line"> <span class="number">5</span>    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line"> <span class="number">6</span>    <span class="built_in">assert</span>(user_data);</span><br><span class="line"> <span class="number">7</span></span><br><span class="line"> <span class="number">8</span>    <span class="comment">//关闭文件描述符</span></span><br><span class="line"> <span class="number">9</span>    <span class="built_in">close</span>(user_data-&gt;sockfd);</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>    <span class="comment">//减少连接数</span></span><br><span class="line"><span class="number">12</span>    http_conn::m_user_count--;</span><br><span class="line"><span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定时器容器设计"><a href="#定时器容器设计" class="headerlink" title="定时器容器设计"></a>定时器容器设计</h3><p>项目中的定时器容器为带头尾结点的升序双向链表，具体的为每个连接创建一个定时器，将其添加到链表中，并按照超时时间升序排列。执行定时任务时，将到期的定时器从链表中删除。</p>
<p>从实现上看，主要涉及双向链表的插入，删除操作，其中添加定时器的事件复杂度是O(n),删除定时器的事件复杂度是O(1)。</p>
<p>升序双向链表主要逻辑如下，具体的，</p>
<ul>
<li><p>创建头尾节点，其中头尾节点没有意义，仅仅统一方便调整</p>
</li>
<li><p>add_timer函数，将目标定时器添加到链表中，添加时按照升序添加</p>
</li>
<li><ul>
<li>若当前链表中只有头尾节点，直接插入</li>
<li>否则，将定时器按升序插入</li>
</ul>
</li>
<li><p>adjust_timer函数，当定时任务发生变化,调整对应定时器在链表中的位置</p>
</li>
<li><ul>
<li>客户端在设定时间内有数据收发,则当前时刻对该定时器重新设定时间，这里只是往后延长超时时间</li>
<li>被调整的目标定时器在尾部，或定时器新的超时值仍然小于下一个定时器的超时，不用调整</li>
<li>否则先将定时器从链表取出，重新插入链表</li>
</ul>
</li>
<li><p>del_timer函数将超时的定时器从链表中删除</p>
</li>
<li><ul>
<li>常规双向链表删除结点</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">//定时器容器类</span></span><br><span class="line">  <span class="number">2</span><span class="keyword">class</span> sort_timer_lst</span><br><span class="line">  <span class="number">3</span>&#123;</span><br><span class="line">  <span class="number">4</span><span class="keyword">public</span>:</span><br><span class="line">  <span class="number">5</span>    <span class="built_in">sort_timer_lst</span>() : <span class="built_in">head</span>( <span class="literal">NULL</span> ), <span class="built_in">tail</span>( <span class="literal">NULL</span> ) &#123;&#125;</span><br><span class="line">  <span class="number">6</span>    <span class="comment">//常规销毁链表</span></span><br><span class="line">  <span class="number">7</span>    ~<span class="built_in">sort_timer_lst</span>()</span><br><span class="line">  <span class="number">8</span>    &#123;</span><br><span class="line">  <span class="number">9</span>        util_timer* tmp = head;</span><br><span class="line"> <span class="number">10</span>        <span class="keyword">while</span>( tmp )</span><br><span class="line"> <span class="number">11</span>        &#123;</span><br><span class="line"> <span class="number">12</span>            head = tmp-&gt;next;</span><br><span class="line"> <span class="number">13</span>            <span class="keyword">delete</span> tmp;</span><br><span class="line"> <span class="number">14</span>            tmp = head;</span><br><span class="line"> <span class="number">15</span>        &#125;</span><br><span class="line"> <span class="number">16</span>    &#125;</span><br><span class="line"> <span class="number">17</span></span><br><span class="line"> <span class="number">18</span>    <span class="comment">//添加定时器，内部调用私有成员add_timer</span></span><br><span class="line"> <span class="number">19</span>    <span class="function"><span class="type">void</span> <span class="title">add_timer</span><span class="params">( util_timer* timer )</span></span></span><br><span class="line"><span class="function"> 20    </span>&#123;</span><br><span class="line"> <span class="number">21</span>        <span class="keyword">if</span>( !timer )</span><br><span class="line"> <span class="number">22</span>        &#123;</span><br><span class="line"> <span class="number">23</span>            <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">24</span>        &#125;</span><br><span class="line"> <span class="number">25</span>        <span class="keyword">if</span>( !head )</span><br><span class="line"> <span class="number">26</span>        &#123;</span><br><span class="line"> <span class="number">27</span>            head = tail = timer;</span><br><span class="line"> <span class="number">28</span>            <span class="keyword">return</span>; </span><br><span class="line"> <span class="number">29</span>        &#125;</span><br><span class="line"> <span class="number">30</span></span><br><span class="line"> <span class="number">31</span>        <span class="comment">//如果新的定时器超时时间小于当前头部结点</span></span><br><span class="line"> <span class="number">32</span>        <span class="comment">//直接将当前定时器结点作为头部结点</span></span><br><span class="line"> <span class="number">33</span>        <span class="keyword">if</span>( timer-&gt;expire &lt; head-&gt;expire )</span><br><span class="line"> <span class="number">34</span>        &#123;</span><br><span class="line"> <span class="number">35</span>            timer-&gt;next = head;</span><br><span class="line"> <span class="number">36</span>            head-&gt;prev = timer;</span><br><span class="line"> <span class="number">37</span>            head = timer;</span><br><span class="line"> <span class="number">38</span>            <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">39</span>        &#125;</span><br><span class="line"> <span class="number">40</span></span><br><span class="line"> <span class="number">41</span>        <span class="comment">//否则调用私有成员，调整内部结点</span></span><br><span class="line"> <span class="number">42</span>        <span class="built_in">add_timer</span>( timer, head );</span><br><span class="line"> <span class="number">43</span>    &#125;</span><br><span class="line"> <span class="number">44</span></span><br><span class="line"> <span class="number">45</span>    <span class="comment">//调整定时器，任务发生变化时，调整定时器在链表中的位置</span></span><br><span class="line"> <span class="number">46</span>    <span class="function"><span class="type">void</span> <span class="title">adjust_timer</span><span class="params">( util_timer* timer )</span></span></span><br><span class="line"><span class="function"> 47    </span>&#123;</span><br><span class="line"> <span class="number">48</span>        <span class="keyword">if</span>( !timer )</span><br><span class="line"> <span class="number">49</span>        &#123;</span><br><span class="line"> <span class="number">50</span>            <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">51</span>        &#125;</span><br><span class="line"> <span class="number">52</span>        util_timer* tmp = timer-&gt;next;</span><br><span class="line"> <span class="number">53</span></span><br><span class="line"> <span class="number">54</span>        <span class="comment">//被调整的定时器在链表尾部</span></span><br><span class="line"> <span class="number">55</span>        <span class="comment">//定时器超时值仍然小于下一个定时器超时值，不调整</span></span><br><span class="line"> <span class="number">56</span>        <span class="keyword">if</span>( !tmp || ( timer-&gt;expire &lt; tmp-&gt;expire ) )</span><br><span class="line"> <span class="number">57</span>        &#123;</span><br><span class="line"> <span class="number">58</span>            <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">59</span>        &#125;</span><br><span class="line"> <span class="number">60</span></span><br><span class="line"> <span class="number">61</span>        <span class="comment">//被调整定时器是链表头结点，将定时器取出，重新插入</span></span><br><span class="line"> <span class="number">62</span>        <span class="keyword">if</span>( timer == head )</span><br><span class="line"> <span class="number">63</span>        &#123;</span><br><span class="line"> <span class="number">64</span>            head = head-&gt;next;</span><br><span class="line"> <span class="number">65</span>            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="number">66</span>            timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="number">67</span>            <span class="built_in">add_timer</span>( timer, head );</span><br><span class="line"> <span class="number">68</span>        &#125;</span><br><span class="line"> <span class="number">69</span></span><br><span class="line"> <span class="number">70</span>        <span class="comment">//被调整定时器在内部，将定时器取出，重新插入</span></span><br><span class="line"> <span class="number">71</span>        <span class="keyword">else</span></span><br><span class="line"> <span class="number">72</span>        &#123;</span><br><span class="line"> <span class="number">73</span>            timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line"> <span class="number">74</span>            timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line"> <span class="number">75</span>            <span class="built_in">add_timer</span>( timer, timer-&gt;next );</span><br><span class="line"> <span class="number">76</span>        &#125;</span><br><span class="line"> <span class="number">77</span>    &#125;</span><br><span class="line"> <span class="number">78</span></span><br><span class="line"> <span class="number">79</span>    <span class="comment">//删除定时器</span></span><br><span class="line"> <span class="number">80</span>    <span class="function"><span class="type">void</span> <span class="title">del_timer</span><span class="params">( util_timer* timer )</span></span></span><br><span class="line"><span class="function"> 81    </span>&#123;</span><br><span class="line"> <span class="number">82</span>        <span class="keyword">if</span>( !timer )</span><br><span class="line"> <span class="number">83</span>        &#123;</span><br><span class="line"> <span class="number">84</span>            <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">85</span>        &#125;</span><br><span class="line"> <span class="number">86</span></span><br><span class="line"> <span class="number">87</span>        <span class="comment">//链表中只有一个定时器，需要删除该定时器</span></span><br><span class="line"> <span class="number">88</span>        <span class="keyword">if</span>( ( timer == head ) &amp;&amp; ( timer == tail ) )</span><br><span class="line"> <span class="number">89</span>        &#123;</span><br><span class="line"> <span class="number">90</span>            <span class="keyword">delete</span> timer;</span><br><span class="line"> <span class="number">91</span>            head = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="number">92</span>            tail = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="number">93</span>            <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">94</span>        &#125;</span><br><span class="line"> <span class="number">95</span></span><br><span class="line"> <span class="number">96</span>        <span class="comment">//被删除的定时器为头结点</span></span><br><span class="line"> <span class="number">97</span>        <span class="keyword">if</span>( timer == head )</span><br><span class="line"> <span class="number">98</span>        &#123;</span><br><span class="line"> <span class="number">99</span>            head = head-&gt;next;</span><br><span class="line"><span class="number">100</span>            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">101</span>            <span class="keyword">delete</span> timer;</span><br><span class="line"><span class="number">102</span>            <span class="keyword">return</span>;</span><br><span class="line"><span class="number">103</span>        &#125;</span><br><span class="line"><span class="number">104</span></span><br><span class="line"><span class="number">105</span>        <span class="comment">//被删除的定时器为尾结点</span></span><br><span class="line"><span class="number">106</span>        <span class="keyword">if</span>( timer == tail )</span><br><span class="line"><span class="number">107</span>        &#123;</span><br><span class="line"><span class="number">108</span>            tail = tail-&gt;prev;</span><br><span class="line"><span class="number">109</span>            tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">110</span>            <span class="keyword">delete</span> timer;</span><br><span class="line"><span class="number">111</span>            <span class="keyword">return</span>;</span><br><span class="line"><span class="number">112</span>        &#125;</span><br><span class="line"><span class="number">113</span></span><br><span class="line"><span class="number">114</span>        <span class="comment">//被删除的定时器在链表内部，常规链表结点删除</span></span><br><span class="line"><span class="number">115</span>        timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line"><span class="number">116</span>        timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line"><span class="number">117</span>        <span class="keyword">delete</span> timer;</span><br><span class="line"><span class="number">118</span>    &#125;</span><br><span class="line"><span class="number">119</span></span><br><span class="line"><span class="number">120</span><span class="keyword">private</span>:</span><br><span class="line"><span class="number">121</span>    <span class="comment">//私有成员，被公有成员add_timer和adjust_time调用</span></span><br><span class="line"><span class="number">122</span>    <span class="comment">//主要用于调整链表内部结点</span></span><br><span class="line"><span class="number">123</span>    <span class="function"><span class="type">void</span> <span class="title">add_timer</span><span class="params">( util_timer* timer, util_timer* lst_head )</span></span></span><br><span class="line"><span class="function">124    </span>&#123;</span><br><span class="line"><span class="number">125</span>        util_timer* prev = lst_head;</span><br><span class="line"><span class="number">126</span>        util_timer* tmp = prev-&gt;next;</span><br><span class="line"><span class="number">127</span></span><br><span class="line"><span class="number">128</span>        <span class="comment">//遍历当前结点之后的链表，按照超时时间找到目标定时器对应的位置，常规双向链表插入操作</span></span><br><span class="line"><span class="number">129</span>        <span class="keyword">while</span>( tmp )</span><br><span class="line"><span class="number">130</span>        &#123;</span><br><span class="line"><span class="number">131</span>            <span class="keyword">if</span>( timer-&gt;expire &lt; tmp-&gt;expire )</span><br><span class="line"><span class="number">132</span>            &#123;</span><br><span class="line"><span class="number">133</span>                prev-&gt;next = timer;</span><br><span class="line"><span class="number">134</span>                timer-&gt;next = tmp;</span><br><span class="line"><span class="number">135</span>                tmp-&gt;prev = timer;</span><br><span class="line"><span class="number">136</span>                timer-&gt;prev = prev;</span><br><span class="line"><span class="number">137</span>                <span class="keyword">break</span>;</span><br><span class="line"><span class="number">138</span>            &#125;</span><br><span class="line"><span class="number">139</span>            prev = tmp;</span><br><span class="line"><span class="number">140</span>            tmp = tmp-&gt;next;</span><br><span class="line"><span class="number">141</span>        &#125;</span><br><span class="line"><span class="number">142</span></span><br><span class="line"><span class="number">143</span>        <span class="comment">//遍历完发现，目标定时器需要放到尾结点处</span></span><br><span class="line"><span class="number">144</span>        <span class="keyword">if</span>( !tmp )</span><br><span class="line"><span class="number">145</span>        &#123;</span><br><span class="line"><span class="number">146</span>            prev-&gt;next = timer;</span><br><span class="line"><span class="number">147</span>            timer-&gt;prev = prev;</span><br><span class="line"><span class="number">148</span>            timer-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">149</span>            tail = timer;</span><br><span class="line"><span class="number">150</span>        &#125;</span><br><span class="line"><span class="number">151</span></span><br><span class="line"><span class="number">152</span>    &#125;</span><br><span class="line"><span class="number">153</span></span><br><span class="line"><span class="number">154</span><span class="keyword">private</span>:</span><br><span class="line"><span class="number">155</span>    <span class="comment">//头尾结点</span></span><br><span class="line"><span class="number">156</span>    util_timer* head;</span><br><span class="line"><span class="number">157</span>    util_timer* tail;</span><br><span class="line"><span class="number">158</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="定时任务处理函数"><a href="#定时任务处理函数" class="headerlink" title="定时任务处理函数"></a>定时任务处理函数</h3><p>使用统一事件源，SIGALRM信号每次被触发，主循环中调用一次定时任务处理函数，处理链表容器中到期的定时器。</p>
<p>具体的逻辑如下，</p>
<ul>
<li>遍历定时器升序链表容器，从头结点开始依次处理每个定时器，直到遇到尚未到期的定时器</li>
<li>若当前时间小于定时器超时时间，跳出循环，即未找到到期的定时器</li>
<li>若当前时间大于定时器超时时间，即找到了到期的定时器，执行回调函数，然后将它从链表中删除，然后继续遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">//定时任务处理函数</span></span><br><span class="line"> <span class="number">2</span><span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 3</span>&#123;</span><br><span class="line"> <span class="number">4</span>    <span class="keyword">if</span>( !head )</span><br><span class="line"> <span class="number">5</span>    &#123;</span><br><span class="line"> <span class="number">6</span>        <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">7</span>    &#125;</span><br><span class="line"> <span class="number">8</span></span><br><span class="line"> <span class="number">9</span>    <span class="comment">//获取当前时间</span></span><br><span class="line"><span class="number">10</span>    <span class="type">time_t</span> cur = <span class="built_in">time</span>( <span class="literal">NULL</span> );</span><br><span class="line"><span class="number">11</span>    util_timer* tmp = head;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span>    <span class="comment">//遍历定时器链表</span></span><br><span class="line"><span class="number">14</span>    <span class="keyword">while</span>( tmp )</span><br><span class="line"><span class="number">15</span>    &#123;</span><br><span class="line"><span class="number">16</span>        <span class="comment">//链表容器为升序排列</span></span><br><span class="line"><span class="number">17</span>        <span class="comment">//当前时间小于定时器的超时时间，后面的定时器也没有到期</span></span><br><span class="line"><span class="number">18</span>        <span class="keyword">if</span>( cur &lt; tmp-&gt;expire )</span><br><span class="line"><span class="number">19</span>        &#123;</span><br><span class="line"><span class="number">20</span>            <span class="keyword">break</span>;</span><br><span class="line"><span class="number">21</span>        &#125;</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span>        <span class="comment">//当前定时器到期，则调用回调函数，执行定时事件</span></span><br><span class="line"><span class="number">24</span>        tmp-&gt;<span class="built_in">cb_func</span>( tmp-&gt;user_data );</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span>        <span class="comment">//将处理后的定时器从链表容器中删除，并重置头结点</span></span><br><span class="line"><span class="number">27</span>        head = tmp-&gt;next;</span><br><span class="line"><span class="number">28</span>        <span class="keyword">if</span>( head )</span><br><span class="line"><span class="number">29</span>        &#123;</span><br><span class="line"><span class="number">30</span>            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">31</span>        &#125;</span><br><span class="line"><span class="number">32</span>        <span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="number">33</span>        tmp = head;</span><br><span class="line"><span class="number">34</span>    &#125;</span><br><span class="line"><span class="number">35</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码分析-如何使用定时器"><a href="#代码分析-如何使用定时器" class="headerlink" title="代码分析-如何使用定时器"></a>代码分析-如何使用定时器</h3><p>服务器首先创建定时器容器链表，然后用统一事件源将异常事件，读写事件和信号事件统一处理，根据不同事件的对应逻辑使用定时器。</p>
<p>具体的，</p>
<ul>
<li>浏览器与服务器连接时，创建该连接对应的定时器，并将该定时器添加到链表上</li>
<li>处理异常事件时，执行定时事件，服务器关闭连接，从链表上移除对应定时器</li>
<li>处理定时信号时，将定时标志设置为true</li>
<li>处理读事件时，若某连接上发生读事件，将对应定时器向后移动，否则，执行定时事件</li>
<li>处理写事件时，若服务器通过某连接给浏览器发送数据，将对应定时器向后移动，否则，执行定时事件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">//定时处理任务，重新定时以不断触发SIGALRM信号</span></span><br><span class="line">  <span class="number">2</span><span class="function"><span class="type">void</span> <span class="title">timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  3</span>&#123;</span><br><span class="line">  <span class="number">4</span>    timer_lst.<span class="built_in">tick</span>();</span><br><span class="line">  <span class="number">5</span>    <span class="built_in">alarm</span>(TIMESLOT);</span><br><span class="line">  <span class="number">6</span>&#125;</span><br><span class="line">  <span class="number">7</span></span><br><span class="line">  <span class="number">8</span><span class="comment">//创建定时器容器链表</span></span><br><span class="line">  <span class="number">9</span><span class="type">static</span> sort_timer_lst timer_lst;</span><br><span class="line"> <span class="number">10</span></span><br><span class="line"> <span class="number">11</span><span class="comment">//创建连接资源数组</span></span><br><span class="line"> <span class="number">12</span>client_data *users_timer = <span class="keyword">new</span> client_data[MAX_FD];</span><br><span class="line"> <span class="number">13</span></span><br><span class="line"> <span class="number">14</span><span class="comment">//超时默认为False</span></span><br><span class="line"> <span class="number">15b</span>ool timeout = <span class="literal">false</span>;</span><br><span class="line"> <span class="number">16</span></span><br><span class="line"> <span class="number">17</span><span class="comment">//alarm定时触发SIGALRM信号</span></span><br><span class="line"> <span class="number">18</span>alarm(TIMESLOT);</span><br><span class="line"> <span class="number">19</span></span><br><span class="line"> <span class="number">20</span><span class="keyword">while</span> (!stop_server)</span><br><span class="line"> <span class="number">21</span>&#123;</span><br><span class="line"> <span class="number">22</span>    <span class="type">int</span> number = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"> <span class="number">23</span>    <span class="keyword">if</span> (number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)</span><br><span class="line"> <span class="number">24</span>    &#123;</span><br><span class="line"> <span class="number">25</span>        <span class="keyword">break</span>;</span><br><span class="line"> <span class="number">26</span>    &#125;</span><br><span class="line"> <span class="number">27</span></span><br><span class="line"> <span class="number">28</span>    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line"> <span class="number">29</span>    &#123;</span><br><span class="line"> <span class="number">30</span>        <span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"> <span class="number">31</span></span><br><span class="line"> <span class="number">32</span>        <span class="comment">//处理新到的客户连接</span></span><br><span class="line"> <span class="number">33</span>        <span class="keyword">if</span> (sockfd == listenfd)</span><br><span class="line"> <span class="number">34</span>        &#123;</span><br><span class="line"> <span class="number">35</span>            <span class="comment">//初始化客户端连接地址</span></span><br><span class="line"> <span class="number">36</span>            <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line"> <span class="number">37</span>            <span class="type">socklen_t</span> client_addrlength = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line"> <span class="number">38</span></span><br><span class="line"> <span class="number">39</span>            <span class="comment">//该连接分配的文件描述符</span></span><br><span class="line"> <span class="number">40</span>            <span class="type">int</span> connfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line"> <span class="number">41</span></span><br><span class="line"> <span class="number">42</span>            <span class="comment">//初始化该连接对应的连接资源</span></span><br><span class="line"> <span class="number">43</span>            users_timer[connfd].address = client_address;</span><br><span class="line"> <span class="number">44</span>            users_timer[connfd].sockfd = connfd;</span><br><span class="line"> <span class="number">45</span></span><br><span class="line"> <span class="number">46</span>            <span class="comment">//创建定时器临时变量</span></span><br><span class="line"> <span class="number">47</span>            util_timer *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line"> <span class="number">48</span>            <span class="comment">//设置定时器对应的连接资源</span></span><br><span class="line"> <span class="number">49</span>            timer-&gt;user_data = &amp;users_timer[connfd];</span><br><span class="line"> <span class="number">50</span>            <span class="comment">//设置回调函数</span></span><br><span class="line"> <span class="number">51</span>            timer-&gt;cb_func = cb_func;</span><br><span class="line"> <span class="number">52</span></span><br><span class="line"> <span class="number">53</span>            <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="number">54</span>            <span class="comment">//设置绝对超时时间</span></span><br><span class="line"> <span class="number">55</span>            timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line"> <span class="number">56</span>            <span class="comment">//创建该连接对应的定时器，初始化为前述临时变量</span></span><br><span class="line"> <span class="number">57</span>            users_timer[connfd].timer = timer;</span><br><span class="line"> <span class="number">58</span>            <span class="comment">//将该定时器添加到链表中</span></span><br><span class="line"> <span class="number">59</span>            timer_lst.<span class="built_in">add_timer</span>(timer);</span><br><span class="line"> <span class="number">60</span>        &#125;</span><br><span class="line"> <span class="number">61</span>        <span class="comment">//处理异常事件</span></span><br><span class="line"> <span class="number">62</span>        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR))</span><br><span class="line"> <span class="number">63</span>        &#123;</span><br><span class="line"> <span class="number">64</span>            <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line"> <span class="number">65</span>            <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line"> <span class="number">66</span></span><br><span class="line"> <span class="number">67</span>            util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line"> <span class="number">68</span>            <span class="keyword">if</span> (timer)</span><br><span class="line"> <span class="number">69</span>            &#123;</span><br><span class="line"> <span class="number">70</span>                timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line"> <span class="number">71</span>            &#125;</span><br><span class="line"> <span class="number">72</span>        &#125;</span><br><span class="line"> <span class="number">73</span></span><br><span class="line"> <span class="number">74</span>        <span class="comment">//处理定时器信号</span></span><br><span class="line"> <span class="number">75</span>        <span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))</span><br><span class="line"> <span class="number">76</span>        &#123;</span><br><span class="line"> <span class="number">77</span>            <span class="comment">//接收到SIGALRM信号，timeout设置为True</span></span><br><span class="line"> <span class="number">78</span>        &#125;</span><br><span class="line"> <span class="number">79</span></span><br><span class="line"> <span class="number">80</span>        <span class="comment">//处理客户连接上接收到的数据</span></span><br><span class="line"> <span class="number">81</span>        <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line"> <span class="number">82</span>        &#123;</span><br><span class="line"> <span class="number">83</span>            <span class="comment">//创建定时器临时变量，将该连接对应的定时器取出来</span></span><br><span class="line"> <span class="number">84</span>            util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line"> <span class="number">85</span>            <span class="keyword">if</span> (users[sockfd].<span class="built_in">read_once</span>())</span><br><span class="line"> <span class="number">86</span>            &#123;</span><br><span class="line"> <span class="number">87</span>                <span class="comment">//若监测到读事件，将该事件放入请求队列</span></span><br><span class="line"> <span class="number">88</span>                pool-&gt;<span class="built_in">append</span>(users + sockfd);</span><br><span class="line"> <span class="number">89</span></span><br><span class="line"> <span class="number">90</span>                <span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line"> <span class="number">91</span>                <span class="comment">//对其在链表上的位置进行调整</span></span><br><span class="line"> <span class="number">92</span>                <span class="keyword">if</span> (timer)</span><br><span class="line"> <span class="number">93</span>                &#123;</span><br><span class="line"> <span class="number">94</span>                    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="number">95</span>                    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line"> <span class="number">96</span>                    timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line"> <span class="number">97</span>                &#125;</span><br><span class="line"> <span class="number">98</span>            &#125;</span><br><span class="line"> <span class="number">99</span>            <span class="keyword">else</span></span><br><span class="line"><span class="number">100</span>            &#123;</span><br><span class="line"><span class="number">101</span>                <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line"><span class="number">102</span>                <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line"><span class="number">103</span>                <span class="keyword">if</span> (timer)</span><br><span class="line"><span class="number">104</span>                &#123;</span><br><span class="line"><span class="number">105</span>                    timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line"><span class="number">106</span>                &#125;</span><br><span class="line"><span class="number">107</span>            &#125;</span><br><span class="line"><span class="number">108</span>        &#125;</span><br><span class="line"><span class="number">109</span>       <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line"><span class="number">110</span>       &#123;</span><br><span class="line"><span class="number">111</span>           util_timer *timer = users_timer[sockfd].timer;</span><br><span class="line"><span class="number">112</span>           <span class="keyword">if</span> (users[sockfd].<span class="built_in">write</span>())</span><br><span class="line"><span class="number">113</span>           &#123;</span><br><span class="line"><span class="number">114</span>                <span class="comment">//若有数据传输，则将定时器往后延迟3个单位</span></span><br><span class="line"><span class="number">115</span>                <span class="comment">//并对新的定时器在链表上的位置进行调整</span></span><br><span class="line"><span class="number">116</span>                <span class="keyword">if</span> (timer)</span><br><span class="line"><span class="number">117</span>                &#123;</span><br><span class="line"><span class="number">118</span>                    <span class="type">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="number">119</span>                    timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line"><span class="number">120</span>                    timer_lst.<span class="built_in">adjust_timer</span>(timer);</span><br><span class="line"><span class="number">121</span>                &#125;</span><br><span class="line"><span class="number">122</span>            &#125;</span><br><span class="line"><span class="number">123</span>            <span class="keyword">else</span></span><br><span class="line"><span class="number">124</span>            &#123;</span><br><span class="line"><span class="number">125</span>                <span class="comment">//服务器端关闭连接，移除对应的定时器</span></span><br><span class="line"><span class="number">126</span>                <span class="built_in">cb_func</span>(&amp;users_timer[sockfd]);</span><br><span class="line"><span class="number">127</span>                <span class="keyword">if</span> (timer)</span><br><span class="line"><span class="number">128</span>                &#123;</span><br><span class="line"><span class="number">129</span>                    timer_lst.<span class="built_in">del_timer</span>(timer);</span><br><span class="line"><span class="number">130</span>                &#125;</span><br><span class="line"><span class="number">131</span>            &#125;</span><br><span class="line"><span class="number">132</span>       &#125;</span><br><span class="line"><span class="number">133</span>    &#125;</span><br><span class="line"><span class="number">134</span>    <span class="comment">//处理定时器为非必须事件，收到信号并不是立马处理</span></span><br><span class="line"><span class="number">135</span>    <span class="comment">//完成读写事件后，再进行处理</span></span><br><span class="line"><span class="number">136</span>    <span class="keyword">if</span> (timeout)</span><br><span class="line"><span class="number">137</span>    &#123;</span><br><span class="line"><span class="number">138</span>        <span class="built_in">timer_handler</span>();</span><br><span class="line"><span class="number">139</span>        timeout = <span class="literal">false</span>;</span><br><span class="line"><span class="number">140</span>    &#125;</span><br><span class="line"><span class="number">141</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定时器优化</strong></p>
<p>这个基于升序双向链表实现的定时器存在着其固有缺点：</p>
<ul>
<li>每次遍历添加和修改定时器的效率偏低(O(n))，使用最小堆结构可以降低时间复杂度降至(O(logn))。</li>
<li>每次以固定的时间间隔触发<code>SIGALRM</code>信号，调用<code>tick</code>函数处理超时连接会造成一定的触发浪费，举个例子，若当前的<code>TIMESLOT=5</code>，即每隔5ms触发一次<code>SIGALRM</code>，跳出循环执行<code>tick</code>函数，这时如果当前即将超时的任务距离现在还有<code>20ms</code>，那么在这个期间，<code>SIGALRM</code>信号被触发了4次，<code>tick</code>函数也被执行了4次，可是在这4次中，前三次触发都是无意义的。对此，我们可以动态的设置<code>TIMESLOT</code>的值，每次将其值设置为<strong>当前最先超时的定时器与当前时间的时间差</strong>，这样每次调用<code>tick</code>函数，超时时间最小的定时器必然到期，并被处理，然后在从时间堆中取一个最先超时的定时器的时间与当前时间做时间差，更新<code>TIMESLOT</code>的值。</li>
</ul>
<h3 id="服务器优化：日志"><a href="#服务器优化：日志" class="headerlink" title="服务器优化：日志"></a>服务器优化：日志</h3><p>日志，由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。<br>这部分内容个人感觉相对抽象一点，涉及单例模式以及单例模式的两种实现方式：懒汉模式和恶汉模式，以及条件变量机制和生产者消费者模型。这里大概就上述提到的几点做下简单解释，具体的还是去看参考中社长的笔记。<br><strong>单例模式</strong><br>最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。<br>实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。</p>
<ul>
<li><p>懒汉模式</p>
<p>：即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化（实例的初始化放在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getinstance</span><br></pre></td></tr></table></figure>

<p>函数内部）</p>
<ul>
<li>经典的线程安全懒汉模式，使用双检测锁模式（<code>p == NULL</code>检测了两次）</li>
<li>利用局部静态变量实现线程安全懒汉模式</li>
</ul>
</li>
<li><p><strong>饿汉模式</strong>：即迫不及待，在程序运行时立即初始化（实例的初始化放在<code>getinstance</code>函数外部，<code>getinstance</code>函数仅返回该唯一实例的指针）。</p>
</li>
</ul>
<p><strong>日志系统的运行机制</strong></p>
<ul>
<li>日志文件<ul>
<li>局部变量的懒汉模式获取实例</li>
<li>生成日志文件，并判断同步和异步写入方式</li>
</ul>
</li>
<li>同步<ul>
<li>判断是否分文件</li>
<li>直接格式化输出内容，将信息写入日志文件</li>
</ul>
</li>
<li>异步<ul>
<li>判断是否分文件</li>
<li>格式化输出内容，将内容写入阻塞队列，创建一个写线程，从阻塞队列取出内容写入日志文件</li>
</ul>
</li>
</ul>
<h3 id="压测（非常关键）"><a href="#压测（非常关键）" class="headerlink" title="压测（非常关键）"></a>压测（非常关键）</h3><p>一个服务器项目，你在本地浏览器键入<code>localhost:9000</code>发现可以运行无异常还不够，你需要对他进行压测（即服务器并发量测试），压测过了，才说明你的服务器比较稳定了。社长的项目是如何压测的呢？<br>用到了一个压测软件叫做Webbench，可以直接在社长的Gtihub里面下载，解压，然后在解压目录打开终端运行命令（<code>-c</code>表示客户端数， <code>-t</code>表示时间）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./webbench -c 10001 -t 5 http://127.0.0.1:9006/</span><br></pre></td></tr></table></figure>



<p>直接解压的<code>webbench-1.5</code>文件夹下的<code>webbench</code>文件可能会因为权限问题找不到命令或者无法执行，这时你需要重新编译一下该文件即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc webbench.c -o webbench</span><br></pre></td></tr></table></figure>



<p>然后我们就可以压测得到结果了（我本人电脑的用户数量<code>-c</code>设置为<code>10500</code>会造成资源不足的错误）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Webbench - Simple Web Benchmark 1.5</span><br><span class="line">Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.</span><br><span class="line"></span><br><span class="line">Benchmarking: GET http://127.0.0.1:9006/</span><br><span class="line">10001 clients, running 5 sec.</span><br><span class="line"></span><br><span class="line">Speed=1044336 pages/min, 2349459 bytes/sec.</span><br><span class="line">Requests: 87028 susceed, 0 failed.</span><br></pre></td></tr></table></figure>



<p><strong>Webbench是什么，介绍一下原理</strong><br>父进程fork若干个子进程，每个子进程在用户要求时间或默认的时间内对目标web循环发出实际访问请求，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在时间到后结束，父进程在所有子进程退出后统计并给用户显示最后的测试结果，然后退出。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://fsxmu.gi.io.com">fs</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://fsxmu.gi.io.com/2023/04/10/TinyWebServer/">http://fsxmu.gi.io.com/2023/04/10/TinyWebServer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://fsxmu.gi.io.com" target="_blank">fs blog in xmu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/">web服务器</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/we/wallhaven-we52vx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/20/USART%E4%B8%B2%E5%8F%A3/" title="USART串口"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">USART串口</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/10/%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0/" title="并发服务器实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">并发服务器实现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/09/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/" title="事件处理模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="title">事件处理模式</div></div></a></div><div><a href="/2023/04/07/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/" title="阻塞&#x2F;非阻塞、同步&#x2F;异步"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-07</div><div class="title">阻塞&#x2F;非阻塞、同步&#x2F;异步</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://w.wallhaven.cc/full/we/wallhaven-we52vx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">fs</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fsxmu/fsxmu.github.io/settings/pages" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/fsbjut@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%B0%81%E8%A3%85%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">线程同步机制封装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RAII"><span class="toc-number">1.1.</span> <span class="toc-text">RAII</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">互斥量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">条件变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">2.</span> <span class="toc-text">功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.</span> <span class="toc-text">锁机制的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">封装的功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%8E%A5%E6%94%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E6%9D%A5%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%91%A2"><span class="toc-number">3.</span> <span class="toc-text">Web服务器如何接收客户端发来的HTTP请求报文呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5I-x2F-O%E6%A8%A1%E6%8B%9Fproactor%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">同步I&#x2F;O模拟proactor模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">静态成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">静态成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-create%E9%99%B7%E9%98%B1"><span class="toc-number">4.3.</span> <span class="toc-text">pthread_create陷阱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E6%8C%87%E9%92%88%E7%9A%84%E9%94%85"><span class="toc-number">4.4.</span> <span class="toc-text">this指针的锅</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%A5%E5%8F%8A%E5%93%8D%E5%BA%94%E6%8E%A5%E6%94%B6%E5%88%B0%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%91%A2"><span class="toc-number">5.</span> <span class="toc-text">Web服务器如何处理以及响应接收到的HTTP请求报文呢?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84"><span class="toc-number">6.</span> <span class="toc-text">数据库连接池是如何运行的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCGI%E6%A0%A1%E9%AA%8C"><span class="toc-number">7.</span> <span class="toc-text">什么是CGI校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90HTTP%E5%93%8D%E5%BA%94%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%99%E7%94%A8%E6%88%B7"><span class="toc-number">8.</span> <span class="toc-text">生成HTTP响应并返回给用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">9.</span> <span class="toc-text">服务器优化：定时器处理非活动链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">10.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A6%82%E8%BF%B0"><span class="toc-number">11.</span> <span class="toc-text">整体概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%80%9A%E7%9F%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">信号通知流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E4%BA%8B%E4%BB%B6%E6%BA%90"><span class="toc-number">12.1.</span> <span class="toc-text">统一事件源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">13.</span> <span class="toc-text">定时器设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">14.</span> <span class="toc-text">定时器容器设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text">定时任务处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">16.</span> <span class="toc-text">代码分析-如何使用定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%EF%BC%9A%E6%97%A5%E5%BF%97"><span class="toc-number">17.</span> <span class="toc-text">服务器优化：日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E6%B5%8B%EF%BC%88%E9%9D%9E%E5%B8%B8%E5%85%B3%E9%94%AE%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">压测（非常关键）</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/16/SPI/" title="SPI">SPI</a><time datetime="2023-06-16T11:51:59.000Z" title="发表于 2023-06-16 19:51:59">2023-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/30/%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/" title="字符设备驱动程序框架">字符设备驱动程序框架</a><time datetime="2023-05-30T09:14:58.000Z" title="发表于 2023-05-30 17:14:58">2023-05-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/25/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/" title="编写第一个驱动程序">编写第一个驱动程序</a><time datetime="2023-05-25T06:07:53.000Z" title="发表于 2023-05-25 14:07:53">2023-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/23/%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%AC%AC-1-%E4%B8%AA%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/" title="开发板的第 1 个驱动实验">开发板的第 1 个驱动实验</a><time datetime="2023-05-23T05:16:38.000Z" title="发表于 2023-05-23 13:16:38">2023-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/11/I2C/" title="I2C">I2C</a><time datetime="2023-05-11T01:23:42.000Z" title="发表于 2023-05-11 09:23:42">2023-05-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By fs</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>