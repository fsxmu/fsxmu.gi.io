<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>阻塞/非阻塞、同步/异步 | fs blog in xmu</title><meta name="author" content="fs"><meta name="copyright" content="fs"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="阻塞&#x2F;非阻塞、同步&#x2F;异步(网络IO)典型的一次IO的两个阶段是什么？数据就绪 和 数据读写 数据就绪：根据系统IO操作的就绪状态（比如说recv函数非阻塞状态需要通过返回值判断）  阻塞 非阻塞  数据读写：根据应用程序和内核的交互方式  同步 异步  陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。  ​		一个典型的网络IO">
<meta property="og:type" content="article">
<meta property="og:title" content="阻塞&#x2F;非阻塞、同步&#x2F;异步">
<meta property="og:url" content="http://fsxmu.gi.io.com/2023/04/07/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/index.html">
<meta property="og:site_name" content="fs blog in xmu">
<meta property="og:description" content="阻塞&#x2F;非阻塞、同步&#x2F;异步(网络IO)典型的一次IO的两个阶段是什么？数据就绪 和 数据读写 数据就绪：根据系统IO操作的就绪状态（比如说recv函数非阻塞状态需要通过返回值判断）  阻塞 非阻塞  数据读写：根据应用程序和内核的交互方式  同步 异步  陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。  ​		一个典型的网络IO">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/we/wallhaven-we52vx.jpg">
<meta property="article:published_time" content="2023-04-07T12:27:23.000Z">
<meta property="article:modified_time" content="2023-04-09T07:17:31.046Z">
<meta property="article:author" content="fs">
<meta property="article:tag" content="web服务器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/we/wallhaven-we52vx.jpg"><link rel="shortcut icon" href="https://w.wallhaven.cc/full/jx/wallhaven-jxwwe5.png"><link rel="canonical" href="http://fsxmu.gi.io.com/2023/04/07/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '阻塞/非阻塞、同步/异步',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-09 15:17:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://w.wallhaven.cc/full/we/wallhaven-we52vx.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/5g/wallhaven-5gzl88.png')"><nav id="nav"><span id="blog-info"><a href="/" title="fs blog in xmu"><span class="site-name">fs blog in xmu</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">阻塞/非阻塞、同步/异步</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-07T12:27:23.000Z" title="发表于 2023-04-07 20:27:23">2023-04-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-09T07:17:31.046Z" title="更新于 2023-04-09 15:17:31">2023-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/web%E6%9C%8D%E5%8A%A1%E5%99%A8/">web服务器</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="阻塞/非阻塞、同步/异步"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="阻塞-x2F-非阻塞、同步-x2F-异步-网络IO"><a href="#阻塞-x2F-非阻塞、同步-x2F-异步-网络IO" class="headerlink" title="阻塞&#x2F;非阻塞、同步&#x2F;异步(网络IO)"></a>阻塞&#x2F;非阻塞、同步&#x2F;异步(网络IO)</h1><p>典型的一次IO的两个阶段是什么？数据就绪 和 数据读写</p>
<p>数据就绪：根据系统IO操作的就绪状态（比如说recv函数非阻塞状态需要通过返回值判断）</p>
<ul>
<li>阻塞</li>
<li>非阻塞</li>
</ul>
<p>数据读写：根据应用程序和内核的交互方式</p>
<ul>
<li>同步</li>
<li>异步</li>
</ul>
<p>陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。</p>
<p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407202958028.png" alt="image-20230407202958028"></p>
<p>​		一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。</p>
<p>​		同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时</p>
<p>（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以</p>
<p>处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。</p>
<ul>
<li><p>同步阻塞</p>
</li>
<li><p>同步非阻塞</p>
</li>
<li><p>异步阻塞</p>
</li>
<li><p>异步非阻塞</p>
</li>
</ul>
<h1 id="Unix-x2F-Linux上的五种IO模型"><a href="#Unix-x2F-Linux上的五种IO模型" class="headerlink" title="Unix&#x2F;Linux上的五种IO模型"></a>Unix&#x2F;Linux上的五种IO模型</h1><h2 id="a-阻塞blocking"><a href="#a-阻塞blocking" class="headerlink" title="a.阻塞blocking"></a>a.阻塞blocking</h2><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。</p>
<p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407214248934.png" alt="image-20230407214248934"></p>
<h2 id="b-非阻塞-non-blocking（NIO）"><a href="#b-非阻塞-non-blocking（NIO）" class="headerlink" title="b.非阻塞 non-blocking（NIO）"></a>b.非阻塞 non-blocking（NIO）</h2><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 EAGAIN。</p>
<p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407214346056.png" alt="image-20230407214346056"></p>
<h2 id="c-IO复用（IO-multiplexing）"><a href="#c-IO复用（IO-multiplexing）" class="headerlink" title="c.IO复用（IO multiplexing）"></a>c.IO复用（IO multiplexing）</h2><p>Linux 用 select&#x2F;poll&#x2F;epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数。</p>
<p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407214417480.png" alt="image-20230407214417480"></p>
<h2 id="d-信号驱动（signal-driven）"><a href="#d-信号驱动（signal-driven）" class="headerlink" title="d.信号驱动（signal-driven）"></a>d.信号驱动（signal-driven）</h2><p>Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO 信号，然后处理 IO 事件。</p>
<p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407214442553.png" alt="image-20230407214442553"></p>
<p>内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。 </p>
<h2 id="e-异步（asynchronous）"><a href="#e-异步（asynchronous）" class="headerlink" title="e.异步（asynchronous）"></a>e.异步（asynchronous）</h2><p>Linux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方</p>
<p>式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407214553352.png" alt="image-20230407214553352"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Asynchronous I/O control block. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> aio_fildes; <span class="comment">/* File desriptor. */</span></span><br><span class="line"><span class="type">int</span> aio_lio_opcode; <span class="comment">/* Operation to be performed. */</span></span><br><span class="line"><span class="type">int</span> aio_reqprio; <span class="comment">/* Request priority offset. */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> *aio_buf; <span class="comment">/* Location of buffer. */</span></span><br><span class="line"><span class="type">size_t</span> aio_nbytes; <span class="comment">/* Length of transfer. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span>;</span> <span class="comment">/* Signal number and value. */</span></span><br><span class="line"><span class="comment">/* Internal members. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> *__<span class="title">next_prio</span>;</span></span><br><span class="line"><span class="type">int</span> __abs_prio;</span><br><span class="line"><span class="type">int</span> __policy;</span><br><span class="line"><span class="type">int</span> __error_code;</span><br><span class="line"><span class="type">__ssize_t</span> __return_value;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line"><span class="type">__off_t</span> aio_offset; <span class="comment">/* File offset. */</span></span><br><span class="line"><span class="type">char</span> __pad[<span class="keyword">sizeof</span> (<span class="type">__off64_t</span>) - <span class="keyword">sizeof</span> (<span class="type">__off_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">__off64_t</span> aio_offset; <span class="comment">/* File offset. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">char</span> __glibc_reserved[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-Web-Server（网页服务器）"><a href="#3-Web-Server（网页服务器）" class="headerlink" title="3.Web Server（网页服务器）"></a><strong>3.Web Server（网页服务器）</strong></h1><p>一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主要功能是通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容（文件、网页等）或返回一个 Error 信息。</p>
<p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407214712976.png" alt="image-20230407214712976"></p>
<p>通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生针对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。</p>
<h1 id="4-HTTP协议-应用层的协议"><a href="#4-HTTP协议-应用层的协议" class="headerlink" title="4.HTTP协议(应用层的协议)"></a>4.HTTP协议(应用层的协议)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求 - 响应协议，它通常运行在TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。</p>
<p>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering TaskForce，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览</p>
<p>器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p>
<p>尽管 TCP&#x2F;IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP&#x2F;IP 协议族使用 TCP 作为其传输层。</p>
<p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比</p>
<p>如”HTTP&#x2F;1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h2><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>以下是 HTTP 请求&#x2F;响应的步骤：</p>
<ol>
<li><p>客户端连接到 Web 服务器</p>
<p>一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接字连接。例如，<a target="_blank" rel="noopener" href="http://www.baidu.com.(url)/">http://www.baidu.com。（URL）</a></p>
</li>
<li><p>发送 HTTP 请求</p>
<p>通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。</p>
</li>
<li><p>服务器接受请求并返回 HTTP 响应</p>
<p>Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个</p>
<p>响应由状态行、响应头部、空行和响应数据 4 部分组成。</p>
</li>
<li><p>释放连接 TCP 连接</p>
<p>若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连</p>
<p>接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
</li>
<li><p>客户端浏览器解析 HTML 内容</p>
<p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据HTML 的语法对其进行格式化，并在浏览器窗口中显示。</p>
</li>
</ol>
<p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<ol>
<li><p>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址</p>
</li>
<li><p>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;</p>
</li>
<li><p>浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三</p>
<p>次握手的第三个报文的数据发送给服务器;</p>
</li>
<li><p>服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器;</p>
</li>
<li><p>释放 TCP 连接;</p>
</li>
<li><p>浏览器将该 HTML 文本并显示内容。</p>
</li>
</ol>
<p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407215049773.png" alt="image-20230407215049773"></p>
<p>HTTP 协议是基于 TCP&#x2F;IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p>
<h2 id="HTTP-请求报文格式"><a href="#HTTP-请求报文格式" class="headerlink" title="HTTP 请求报文格式"></a><strong>HTTP</strong> <strong>请求报文格式</strong></h2><p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407215119895.png" alt="image-20230407215119895"></p>
<p>GET &#x2F; HTTP&#x2F;1.1</p>
<p>Host: <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></p>
<p>User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko&#x2F;20100101 Firefox&#x2F;86.0</p>
<p>Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,<em>&#x2F;</em>;q&#x3D;0.8</p>
<p>Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</p>
<p>Accept-Encoding: gzip, deflate, br</p>
<p>Connection: keep-alive</p>
<p>Cookie: BAIDUID&#x3D;6729CB682DADC2CF738F533E35162D98:FG&#x3D;1;</p>
<p>BIDUPSID&#x3D;6729CB682DADC2CFE015A8099199557E; PSTM&#x3D;1614320692; BD_UPN&#x3D;13314752;</p>
<p>BDORZ&#x3D;FFFB88E999055A3F8A630C64834BD6D0;</p>
<p>__yjs_duid&#x3D;1_d05d52b14af4a339210722080a668ec21614320694782; BD_HOME&#x3D;1;</p>
<p>H_PS_PSSID&#x3D;33514_33257_33273_31660_33570_26350;</p>
<p>BA_HECTOR&#x3D;8h2001alag0lag85nk1g3hcm60q</p>
<p>Upgrade-Insecure-Requests: 1</p>
<p>Cache-Control: max-age&#x3D;0</p>
<h2 id="HTTP响应报文格式"><a href="#HTTP响应报文格式" class="headerlink" title="HTTP响应报文格式"></a><strong>HTTP响应报文格式</strong></h2><p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407215143145.png" alt="image-20230407215143145"></p>
<p>HTTP&#x2F;1.1 200 OK</p>
<p>Bdpagetype: 1</p>
<p>Bdqid: 0xf3c9743300024ee4</p>
<p>Cache-Control: private</p>
<p>Connection: keep-alive</p>
<p>Content-Encoding: gzip</p>
<p>Content-Type: text&#x2F;html;charset&#x3D;utf-8</p>
<p>Date: Fri, 26 Feb 2021 08:44:35 GMT</p>
<p>Expires: Fri, 26 Feb 2021 08:44:35 GMT</p>
<p>Server: BWS&#x2F;1.1</p>
<p>Set-Cookie: BDSVRTM&#x3D;13; path&#x3D;&#x2F;</p>
<p>Set-Cookie: BD_HOME&#x3D;1; path&#x3D;&#x2F;</p>
<p>Set-Cookie: H_PS_PSSID&#x3D;33514_33257_33273_31660_33570_26350; path&#x3D;&#x2F;; domain&#x3D;.baidu.com</p>
<p>Strict-Transport-Security: max-age&#x3D;172800</p>
<p>Traceid: 1614329075128412289017566699583927635684</p>
<p>X-Ua-Compatible: IE&#x3D;Edge,chrome&#x3D;1</p>
<p>Transfer-Encoding: chunked</p>
<h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a><strong>HTTP请求方法</strong></h2><p>HTTP&#x2F;1.1 协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p>
<ol>
<li><p>GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。</p>
</li>
<li><p>HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</p>
</li>
<li><p>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含</p>
<p>在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p>
</li>
<li><p>PUT：向指定资源位置上传其最新内容。</p>
</li>
<li><p>DELETE：请求服务器删除 Request-URI 所标识的资源。</p>
</li>
<li><p>TRACE：回显服务器收到的请求，主要用于测试或诊断。</p>
</li>
<li><p>OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用’*’来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。</p>
</li>
<li><p>CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服</p>
<p>务器的链接（经由非加密的 HTTP 代理服务器）。</p>
</li>
</ol>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a><strong>HTTP状态码</strong></h2><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p>
<p>状态代码的第一个数字代表当前响应的类型：</p>
<ul>
<li>1xx消息——请求已被服务器接收，继续处理</li>
<li>2xx成功——请求已成功被服务器接收、理解、并接受</li>
<li>3xx重定向——需要后续操作才能完成这一请求</li>
<li>4xx请求错误——请求含有词法错误或者无法被执行</li>
<li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li>
</ul>
<p>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。</p>
<p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407215423020.png" alt="image-20230407215423020"></p>
<h1 id="服务器编程基本框架"><a href="#服务器编程基本框架" class="headerlink" title="服务器编程基本框架"></a><strong>服务器编程基本框架</strong></h1><p>虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。</p>
<p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407225547405.png" alt="image-20230407225547405"></p>
<p><img src="/../images/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/image-20230407225603366.png" alt="image-20230407225603366"></p>
<p>I&#x2F;O 处理单元是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收</p>
<p>客户数据，将服务器响应数据返回给客户端。但是数据的收发不一定在 I&#x2F;O 处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。</p>
<p>一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I&#x2F;O 处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。</p>
<p>网络存储单元可以是数据库、缓存和文件，但不是必须的。</p>
<p>请求队列是各单元之间的通信方式的抽象。I&#x2F;O 处理单元接收到客户请求时，需要以某种方式通知一个</p>
<p>逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://fsxmu.gi.io.com">fs</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://fsxmu.gi.io.com/2023/04/07/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/">http://fsxmu.gi.io.com/2023/04/07/%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://fsxmu.gi.io.com" target="_blank">fs blog in xmu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/web%E6%9C%8D%E5%8A%A1%E5%99%A8/">web服务器</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/we/wallhaven-we52vx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/09/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/" title="事件处理模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">事件处理模式</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/07/post/" title="ADC"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ADC</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/10/TinyWebServer/" title="TinyWebServer"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="title">TinyWebServer</div></div></a></div><div><a href="/2023/04/09/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/" title="事件处理模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-09</div><div class="title">事件处理模式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://w.wallhaven.cc/full/we/wallhaven-we52vx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">fs</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/fsxmu/fsxmu.github.io/settings/pages" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/fsbjut@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E-x2F-%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%90%8C%E6%AD%A5-x2F-%E5%BC%82%E6%AD%A5-%E7%BD%91%E7%BB%9CIO"><span class="toc-number">1.</span> <span class="toc-text">阻塞&#x2F;非阻塞、同步&#x2F;异步(网络IO)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unix-x2F-Linux%E4%B8%8A%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">Unix&#x2F;Linux上的五种IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#a-%E9%98%BB%E5%A1%9Eblocking"><span class="toc-number">2.1.</span> <span class="toc-text">a.阻塞blocking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b-%E9%9D%9E%E9%98%BB%E5%A1%9E-non-blocking%EF%BC%88NIO%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">b.非阻塞 non-blocking（NIO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-IO%E5%A4%8D%E7%94%A8%EF%BC%88IO-multiplexing%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">c.IO复用（IO multiplexing）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%EF%BC%88signal-driven%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">d.信号驱动（signal-driven）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#e-%E5%BC%82%E6%AD%A5%EF%BC%88asynchronous%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">e.异步（asynchronous）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Web-Server%EF%BC%88%E7%BD%91%E9%A1%B5%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3.Web Server（网页服务器）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-HTTP%E5%8D%8F%E8%AE%AE-%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.</span> <span class="toc-text">4.HTTP协议(应用层的协议)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">4.2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">HTTP 请求报文格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">HTTP响应报文格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">HTTP请求方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">4.7.</span> <span class="toc-text">HTTP状态码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6"><span class="toc-number">5.</span> <span class="toc-text">服务器编程基本框架</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/16/SPI/" title="SPI">SPI</a><time datetime="2023-06-16T11:51:59.000Z" title="发表于 2023-06-16 19:51:59">2023-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/30/%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/" title="字符设备驱动程序框架">字符设备驱动程序框架</a><time datetime="2023-05-30T09:14:58.000Z" title="发表于 2023-05-30 17:14:58">2023-05-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/25/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/" title="编写第一个驱动程序">编写第一个驱动程序</a><time datetime="2023-05-25T06:07:53.000Z" title="发表于 2023-05-25 14:07:53">2023-05-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/23/%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E7%AC%AC-1-%E4%B8%AA%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C/" title="开发板的第 1 个驱动实验">开发板的第 1 个驱动实验</a><time datetime="2023-05-23T05:16:38.000Z" title="发表于 2023-05-23 13:16:38">2023-05-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/11/I2C/" title="I2C">I2C</a><time datetime="2023-05-11T01:23:42.000Z" title="发表于 2023-05-11 09:23:42">2023-05-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By fs</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>